# JS算法

 **leetcode coinchange**

  **leetcode pascals triangle**

**English number to normal number and explain it**

**Binary tree level order traversal**

  
**Given a sorted array, find the target's first and last index**

**eg. \[1, 2, 2, 3, 3, 4, 4, 5, 6, 7\] target = 2**

**return \[1, 2\]**

**follow up: no while \(left + 1 &lt; right\) template**



**3. Given a string with char a, b, c**

**ab ba =&gt; c**

**ac ca =&gt; b**

**bc cb =&gt; a**

**return the final string after replacement**

**eg. str = "ccabc" =&gt; "cbbc" =&gt; "abc" =&gt; "cc"**  


**Given two BST. How to merge it into one balanced BST?**

**what about one BST is much smaller than the other?**  


**level order of tree to traverse in js code.**



[**https://leetcode.com/problems/delete-node-in-a-linked-list/**](https://leetcode.com/problems/delete-node-in-a-linked-list/)\*\*\*\*

**find 2 top occurances of a string when the string is too long**  


![](https://lh3.googleusercontent.com/kBAtLGIcW1F3KYdaLS-iP4CYZOjcSx6aYg1fMxxd4171WTRyMMrhof__hg7KHvesOy651CRh5hMAZW3q88vvV8UYJPM86jVY-xsxb532ruPFPO2lYWALaQQySbNui0fdP4nDytZU)

![](https://lh5.googleusercontent.com/lWMFOlyDs7n9GTGbASRXzipss2xpOxpSe6EULtnpLMi_tfgn3ySEKWI0is4oaAGk8Dh4LGBbR5re0kghWftPI4nRQnMl6-GX6SXJXCDaP6Ffsxbbxqvo7KF-g2ltfFn5lRARRDb1)

**一个人初始有1chip去赌博,两种方式 1.一次赌1个chip  2.一次all in所有的钱**

**写一个函数f\(N,K\)**

**N 代表最后从赌场赢的钱 ,K代表最多 可以all in  K 次。返回 赢N块钱所用的最少次数。**  


**.leetcode 287. Find the Duplicate Number  
  array不是默认sort的，先随便写一个，然后会有下面三个follow up，主要是我写不出来他放宽了条件，一步步引导你  
  如果时间复杂度要linear，可以用更多空间  
  如果时间复杂度要linear，constant space  
  如果时间复杂度要linear，constant space，还要保留原本array**



**Tree traverse**

**\(a\) Inorder \(Left, Root, Right\)** 

**\(b\) Preorder \(Root, Left, Right\)**

**\(c\) Postorder \(Left, Right, Root\)**  


![](https://lh4.googleusercontent.com/4sME8zAJWclcA9C4hNhEDkdDYwIYQ4y98jRmgo1zvhCJ5i_pDju0AH3mfl-kgs-QuC47AdTOeHaoDx0I3NGbPgEBmK81D9BAtJskDEofy_ZVBNcEx_bbh6n_DvGfZ5H3RqeQzzBN)





![](https://lh3.googleusercontent.com/z-gU-9yEIJwel9_Ioyuc6dacYqe1_gh0M4NdXeGI_87gmNYeW6pIqvtsCKuCjWJdX0MfVcN7efmLjSn7WIXi74jzvrJlQ9DEkKWp3HvxPkrsmfap6spN5qPoYp5HgR45X3K7Uv1e)

**quick sort（mid）**

**sort singlely linked list （merge，mid，快慢指针）**

 **valid palindrom leetcode 680, follow up delete at most 2 character**

**write a function to return a list that contains the characters and the frequency of the characters**

**2sum, 3sum,4sum**



**1 like  101 \#1.**

    **give a matrix with some 0 and 1. find the max area of connected 1.** 

  **solution. for loop find matrix of value 1. then do dfs to calculate the area. return the max area.**  


 **ZigZag Conversion:** [**https://leetcode.com/problems/zigzag-conversion/**](https://leetcode.com/problems/zigzag-conversion/)  


\*\*\*\*

**given a dependency object like this:**

 **input = {**

 **A : \[B,C\],**

 **B:  \[C, D\],**

 **C:  \[E\],**

 **E:  \[F\]**

**}**

**means A needs dependencies B, C  before install A.**

**\(A,B,C...here is module\)**

**write a function, take input above and return a installing order sequence:**

**F,E,C,D,B,A**   


 **This question is similar to Leetcode Course Schedule.** 

 **I give a topological sort solution first, and the interviewer asked me to write down every step and every detail about this solution on the whiteboard.** 

 **然后面试官让给一个更快的方法,   我说这题最优解就是拓扑排序, 她说要我想一想real-life denpendency tree, 然后把她的这个例子画出来。 画出来后这个例子就是一棵树, 也就是所有的denpendency有一个统一的root, 我说这个例子的话, 其实可以直接用post-order traverse就可以了, 她说这就是她想要的, 我写完代码后她表示满意。\(但我后来想了想她这个例子是不成立的, 因为一旦由多个root就相当于依然是一个graph, 我没和她争论, 就按照他的意思写完了。 \)**  
  
  


![](https://lh5.googleusercontent.com/55_OJxIhooQ3sEL-mrUdwGpAtEE8BNWlysu3wh46PekYaqGz6vUgmzbVdq6ld7iOYY7HXpW_WB17j9OBKpGigcl96caJHP10V64pK1dM0B-zrBqfPHaDNPniVdTABfIyuffytVZJ)

\*\*\*\*

**Coding: Leetcode House Robber I**

**isValidBST**

**Leetcode 805**

**coding: check prime number**

**coding: best time to buy and sell stock**

\*\*\*\*

  
  


